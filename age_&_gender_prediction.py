# -*- coding: utf-8 -*-
"""age & gender 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13PnRc_J0QMeLO8WX_-a90Yje4pYUYLd7
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import cv2
from google.colab import drive
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau
from tensorflow.keras.preprocessing.image import ImageDataGenerator

drive.mount('/content/drive')

zip_path = "/content/drive/MyDrive/datasets/archive.zip"  #change this to your actual file path

#create a directory to extract to
!mkdir -p "/content/UTKFace_extracted"

#extract the zip file
!unzip -q "{zip_path}" -d "/content/UTKFace_extracted"

#check what was extracted
!ls "/content/UTKFace_extracted"

dataset_path = "/content/UTKFace_extracted" 

#if the images are in a subdirectory, check the structure
import os
print(os.listdir(dataset_path))

#update path if needed, e.g., if images are in a subfolder
#dataset_path = "/content/UTKFace_extracted/UTKFace"
dataset_path = "UTKFace_extracted" 
image_size = 128
batch_size = 32

def find_image_directory(base_path):
    for root, dirs, files in os.walk(base_path):
        jpg_count = len([f for f in files if f.lower().endswith('.jpg')])
        png_count = len([f for f in files if f.lower().endswith('.png')])
        if jpg_count > 0 or png_count > 0:
            print(f"Found {jpg_count + png_count} images in {root}")
            return root
    return base_path

dataset_path = find_image_directory(dataset_path)
print(f"Using dataset path: {dataset_path}")

#function to load and preprocess images
def load_dataset(dataset_path):
    images = []
    ages = []
    genders = []

    print(f"Looking for images in: {dataset_path}")
    file_count = 0
    error_count = 0

    for filename in os.listdir(dataset_path):
        file_count += 1
        if filename.endswith('.jpg') or filename.endswith('.png'):
            try:
                parts = filename.split('_')
                age = int(parts[0])
                gender = int(parts[1])  # 0 for male, 1 for female

                img_path = os.path.join(dataset_path, filename)
                img = cv2.imread(img_path)
                if img is None:
                    error_count += 1
                    if error_count <= 5:
                        print(f"Could not read image: {img_path}")
                    continue

                img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  #convert to rgb
                img = cv2.resize(img, (image_size, image_size))  #resize
                img = img / 255.0  #normalize

                #append to lists
                images.append(img)
                ages.append(age)
                genders.append(gender)

            except Exception as e:
                error_count += 1
                if error_count <= 5:  #only print first few errors
                    print(f"Error processing {filename}: {e}")
                continue

    print(f"Processed {file_count} files, encountered {error_count} errors, loaded {len(images)} valid images")
    return np.array(images), np.array(ages), np.array(genders)

#load the dataset
print("Loading dataset...")
images, ages, genders = load_dataset(dataset_path)
print(f"Dataset loaded: {len(images)} images")

#verify we have enough images
if len(images) == 0:
    raise ValueError("No valid images were loaded. Please check the dataset path and file format.")

#quick visualization of some sample images
def visualize_samples(images, ages, genders, num_samples=5):
    plt.figure(figsize=(15, 3))
    indices = np.random.choice(range(len(images)), num_samples, replace=False)

    for i, idx in enumerate(indices):
        plt.subplot(1, num_samples, i+1)
        plt.imshow(images[idx])
        gender_label = "Female" if genders[idx] == 1 else "Male"
        plt.title(f"Age: {ages[idx]}, Gender: {gender_label}")
        plt.axis('off')

    plt.tight_layout()
    plt.show()

#visualize a few samples
if len(images) > 0:
    visualize_samples(images, ages, genders)

#split the dataset into training and testing sets
X_train, X_test, age_train, age_test, gender_train, gender_test = train_test_split(
    images, ages, genders, test_size=0.2, random_state=42
)

print(f"Training set: {len(X_train)} images")
print(f"Testing set: {len(X_test)} images")

#data augmentation for training set
datagen = ImageDataGenerator(
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

# Build the CNN model
def build_model(input_shape):
    # Input layer
    inputs = Input(shape=input_shape)

    # Convolutional layers
    x = Conv2D(32, (3, 3), activation='relu', padding='same')(inputs)
    x = MaxPooling2D(pool_size=(2, 2))(x)

    x = Conv2D(64, (3, 3), activation='relu', padding='same')(x)
    x = MaxPooling2D(pool_size=(2, 2))(x)

    x = Conv2D(128, (3, 3), activation='relu', padding='same')(x)
    x = MaxPooling2D(pool_size=(2, 2))(x)

    x = Conv2D(256, (3, 3), activation='relu', padding='same')(x)
    x = MaxPooling2D(pool_size=(2, 2))(x)

    # Flatten the output
    x = Flatten()(x)

    # Fully connected layers
    x = Dense(512, activation='relu')(x)
    x = Dropout(0.5)(x)
    x = Dense(256, activation='relu')(x)
    x = Dropout(0.5)(x)

    # Output layers
    age_output = Dense(1, name='age_output')(x)  # Regression task
    gender_output = Dense(1, activation='sigmoid', name='gender_output')(x)  # Binary classification

    # Create model
    model = Model(inputs=inputs, outputs=[age_output, gender_output])

    # Compile model
    model.compile(optimizer='adam',
              loss={'age_output': 'mse', 'gender_output': 'binary_crossentropy'},
              metrics={'age_output': 'mae', 'gender_output': 'accuracy'})


    return model

model = build_model((image_size, image_size, 3))
model.summary()

def multi_output_generator(X, y_age, y_gender, batch_size=32):
    while True:
        # Get random batch indices
        idx = np.random.randint(0, X.shape[0], batch_size)

        # Get batch data
        batch_X = X[idx]
        batch_age = y_age[idx]
        batch_gender = y_gender[idx]

        yield batch_X, {'age_output': batch_age, 'gender_output': batch_gender}

history = model.fit(
    multi_output_generator(X_train, age_train, gender_train, batch_size),
    steps_per_epoch=len(X_train) // batch_size,
    epochs=50,
    validation_data=(X_test, {'age_output': age_test, 'gender_output': gender_test}),
)

#evaluate the model
evaluation = model.evaluate(X_test, {'age_output': age_test, 'gender_output': gender_test})
print(f"Test Loss: {evaluation[0]}")
print(f"Age MAE: {evaluation[1]}")
print(f"Gender Accuracy: {evaluation[3]}")

#plot training history
plt.figure(figsize=(12, 4))

#plot age MAE
plt.subplot(1, 2, 1)
plt.plot(history.history['age_output_mae'])
plt.plot(history.history['val_age_output_mae'])
plt.title('Age Mean Absolute Error')
plt.ylabel('MAE')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper right')

#plot gender accuracy
plt.subplot(1, 2, 2)
plt.plot(history.history['gender_output_accuracy'])
plt.plot(history.history['val_gender_output_accuracy'])
plt.title('Gender Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='lower right')

plt.tight_layout()
plt.show()

#save the model
model.save('age_gender_model.h5')
print("Model saved to 'age_gender_model.h5'")

#function to make predictions on new images
def predict_age_gender(image_path, model):
    #load and preprocess the image
    img = cv2.imread(image_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = cv2.resize(img, (image_size, image_size))
    img = img / 255.0
    img = np.expand_dims(img, axis=0)

    #make prediction
    age_pred, gender_pred = model.predict(img)

    #process predictions
    age = int(age_pred[0][0])
    gender = "Female" if gender_pred[0][0] > 0.5 else "Male"

    return age, gender, img[0] #returns preprocesed image

#function to capture image from webcam and predict
def capture_and_predict():
    from IPython.display import display, Javascript
    from google.colab.output import eval_js
    from base64 import b64decode

    # JavaScript function for capturing image from webcam
    js = """
    async function takePhoto() {
      // Check if webcam access is available
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        return {success: false, error: "Webcam not available"};
      }

      try {
        const videoElement = document.createElement('video');
        const canvasElement = document.createElement('canvas');
        const stream = await navigator.mediaDevices.getUserMedia({video: true});

        videoElement.srcObject = stream;
        await new Promise(resolve => videoElement.onloadedmetadata = resolve);
        videoElement.play();

        // Set canvas size to match video dimensions
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;

        // Draw video frame to canvas
        const context = canvasElement.getContext('2d');
        context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

        // Stop the camera
        stream.getTracks().forEach(track => track.stop());

        // Convert canvas to data URL
        const dataURL = canvasElement.toDataURL('image/jpeg');

        return {success: true, dataURL: dataURL};
      } catch (error) {
        return {success: false, error: error.toString()};
      }
    }
    """

    # Execute JavaScript to take photo
    display(Javascript(js))
    result = eval_js('takePhoto()')

    if result['success']:
        # Decode base64 image
        image_data = b64decode(result['dataURL'].split(',')[1])

        # Save image temporarily
        temp_file = 'temp_capture.jpg'
        with open(temp_file, 'wb') as f:
            f.write(image_data)

        # Predict age and gender
        age, gender, img = predict_age_gender(temp_file, model)

        # Display captured image with predictions
        plt.figure(figsize=(5, 5))
        plt.imshow(img)
        plt.title(f"Predicted Age: {age}, Gender: {gender}")
        plt.axis('off')
        plt.show()

        print(f"Predicted Age: {age}")
        print(f"Predicted Gender: {gender}")
    else:
        print(f"Error capturing image: {result.get('error', 'Unknown error')}")

# Execute webcam capture and prediction
print("\nCapturing image from webcam...")
try:
    capture_and_predict()
except Exception as e:
    print(f"Error during webcam capture: {str(e)}")
    print("Continuing with file upload method...")

# Example for prediction on a file upload
from google.colab import files

def upload_and_predict():
    uploaded = files.upload()

    for filename in uploaded.keys():
        print(f"Predicting for {filename}...")

        # Predict age and gender
        age, gender, img = predict_age_gender(filename, model)

        # Display uploaded image with predictions
        plt.figure(figsize=(5, 5))
        plt.imshow(img)
        plt.title(f"Predicted Age: {age}, Gender: {gender}")
        plt.axis('off')
        plt.show()

        print(f"Predicted Age: {age}")
        print(f"Predicted Gender: {gender}")

print("\nUpload an image for age and gender prediction:")
upload_and_predict()

